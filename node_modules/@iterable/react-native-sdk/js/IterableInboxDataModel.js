'use strict';
import { NativeModules } from 'react-native';
import { IterableInAppLocation, IterableHtmlInAppContent } from './IterableInAppClasses';
import { Iterable } from './Iterable';
const RNIterableAPI = NativeModules.RNIterableAPI;
class IterableInboxDataModel {
    filterFn;
    comparatorFn;
    dateMapperFn;
    constructor() {
    }
    set(filter, comparator, dateMapper) {
        this.filterFn = filter;
        this.comparatorFn = comparator;
        this.dateMapperFn = dateMapper;
    }
    getFormattedDate(message) {
        if (message.createdAt === undefined) {
            return "";
        }
        if (this.dateMapperFn) {
            return this.dateMapperFn(message);
        }
        else {
            return this.defaultDateMapper(message);
        }
    }
    getHtmlContentForMessageId(id) {
        Iterable.logger.log("IterableInboxDataModel.getHtmlContentForItem messageId: " + id);
        return RNIterableAPI.getHtmlInAppContentForMessage(id).then((content) => {
            return IterableHtmlInAppContent.fromDict(content);
        });
    }
    setMessageAsRead(id) {
        Iterable.logger.log("IterableInboxDataModel.setMessageAsRead");
        RNIterableAPI.setReadForMessage(id, true);
    }
    deleteItemById(id, deleteSource) {
        Iterable.logger.log("IterableInboxDataModel.deleteItemById");
        RNIterableAPI.removeMessage(id, IterableInAppLocation.inbox, deleteSource);
    }
    async refresh() {
        return RNIterableAPI.getInboxMessages().then((messages) => {
            return this.processMessages(messages);
        }, () => {
            return [];
        });
    }
    // inbox session tracking functions
    startSession(visibleRows = []) {
        RNIterableAPI.startSession(visibleRows);
    }
    async endSession(visibleRows = []) {
        await this.updateVisibleRows(visibleRows);
        RNIterableAPI.endSession();
    }
    updateVisibleRows(visibleRows = []) {
        RNIterableAPI.updateVisibleRows(visibleRows);
    }
    // private/internal
    static sortByMostRecent = (message1, message2) => {
        let createdAt1 = message1.createdAt ?? new Date(0);
        let createdAt2 = message2.createdAt ?? new Date(0);
        if (createdAt1 < createdAt2)
            return 1;
        if (createdAt1 > createdAt2)
            return -1;
        return 0;
    };
    defaultDateMapper(message) {
        if (message.createdAt === undefined) {
            return "";
        }
        let createdAt;
        if (typeof message.createdAt === "string") {
            createdAt = new Date(parseInt(message.createdAt));
        }
        else {
            createdAt = new Date(message.createdAt);
        }
        var defaultDateString = `${createdAt.toLocaleDateString()} at ${createdAt.toLocaleTimeString()}`;
        return defaultDateString;
    }
    processMessages(messages) {
        return this.sortAndFilter(messages).map(IterableInboxDataModel.getInboxRowViewModelForMessage);
    }
    sortAndFilter(messages) {
        var sortedFilteredMessages = messages.slice();
        if (this.filterFn != undefined) {
            sortedFilteredMessages = sortedFilteredMessages.filter(this.filterFn);
        }
        if (this.comparatorFn != undefined) {
            sortedFilteredMessages.sort(this.comparatorFn);
        }
        else {
            sortedFilteredMessages.sort(IterableInboxDataModel.sortByMostRecent);
        }
        return sortedFilteredMessages;
    }
    static getInboxRowViewModelForMessage(message) {
        return {
            title: message.inboxMetadata?.title ?? "",
            subtitle: message.inboxMetadata?.subtitle,
            imageUrl: message.inboxMetadata?.icon,
            createdAt: message.createdAt,
            read: message.read,
            inAppMessage: message
        };
    }
}
export default IterableInboxDataModel;
